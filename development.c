#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           leftArm,       tmotorVex393, openLoop)
#pragma config(Motor,  port5,           rightArm,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           leftIntake,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           rightIntake,   tmotorVex393HighSpeed, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "user_control.c"
#include "PidLib.c"
#include "profiling.c"

#define ENCODER_TICKS_PER_INCH 49.94

task main() {
	//profileMotor(leftDrive);

	pidController* drivePid = PidControllerInit(0.0025, 0.0, 0.02, I2C_2);

	int d = 30;

	int initial = nMotorEncoder[leftDrive];
  int ticks = d * ENCODER_TICKS_PER_INCH;
  int target = initial + ticks;

  drivePid->target_value = target;

  while (true) {
  	int motor_cmd = PidControllerUpdate(drivePid);
    setDrivePwr(motor_cmd);

   // if (motor_cmd > max_val) {
  	//	max_val = motor_cmd;
  	//	writeDebugStreamLine("%d", max_val);
  	//}

    wait1Msec(15);
	}
}
